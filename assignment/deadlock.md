# LAB4: 死锁  
### 运行结果  
![](https://github.com/ybCliff/Screenshot/blob/master/deadlock_count=20000.jpg?raw=true)  
可以看到，最后程序卡在了第八次。PS：有时候可能运行完100次都没能遇到死锁情况，所以需要多跑几次  
### 产生死锁的四个必要条件  
1. **互斥条件**  
某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。如独木桥就是一种独占资源，两方的人不能同时过桥。  

2. **不可抢占条件**  
进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。如过独木桥的人不能强迫对方后退，也不能非法地将对方推下桥，必须是桥上的人自己过桥后空出桥面（即主动释放占有资源），对方的人才能过桥。  

3. **占有且申请条件**  
进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。还以过独木桥为例，甲乙两人在桥上相遇。甲走过一段桥面（即占有了一些资源），还需要走其余的桥面（申请新的资源），但那部分桥面被乙占有（乙走过一段桥面）。甲过不去，前进不能，又不后退；乙也处于同样的状况。   

4. **循环等待条件**  
存在一个进程等待序列{P1，P2，...，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，......，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。就像前面的过独木桥问题，甲等待乙占有的桥面，而乙又等待甲占有的桥面，从而彼此循环等待。

### 实验结果解释
上述实验之所以会出现死锁，玄机就在`count`的取值上。  
假设一个线程调用`start`方法后，需要的调度时间为`t1`  
假设count取值会让主线程空等待时间`t2`  
这时候如果 `t1 == t2 `   
主线程执行`a.methodA(b)`，会占有`a`资源而申请`b`资源  
新线程执行`b.methodB(a)`，会占有`b`资源而申请`a`资源  
所以参照死锁发生的四个必要条件，这种情况下就会发生死锁  

另外，根据我电脑CPU的繁忙程度，当我令`count = 0 || count = 100W`时，几乎不再会发生死锁  
结果如下：  
1. **count = 0**  
![](https://github.com/ybCliff/Screenshot/blob/master/deadlock_count=0.jpg?raw=true)  
2. **count = 1000000**  
![](https://github.com/ybCliff/Screenshot/blob/master/deadlock_count=1000000.jpg?raw=true)  

从上面的结果也可以说明，正是我改变了`count`，令`t1 != t2`，所以才尽可能避免了死锁的发生  
